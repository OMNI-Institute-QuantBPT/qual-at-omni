<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.57">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Data Prep</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


<link rel="stylesheet" href="styles.css">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a href="https://www.omni.org/" class="navbar-brand navbar-brand-logo">
    <img src="https://github.com/rfortherestofus/omni/blob/main/inst/assets/images/logo-no-text.png?raw=true" alt="Logo of the Omni Institute" class="navbar-logo">
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="./index.html"> 
<span class="menu-text">Home</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./fun_standards.html"> 
<span class="menu-text">Fundamental Standards</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./methods.html"> 
<span class="menu-text">Methods</span></a>
  </li>  
  <li class="nav-item dropdown ">
    <a class="nav-link dropdown-toggle" href="#" id="nav-menu-analysis" role="link" data-bs-toggle="dropdown" aria-expanded="false">
 <span class="menu-text">Analysis</span>
    </a>
    <ul class="dropdown-menu" aria-labelledby="nav-menu-analysis">    
        <li class="dropdown-header">Data Prep</li>
        <li>
    <a class="dropdown-item" href="./data_prep.html">
 <span class="dropdown-text">Subtab1 test</span></a>
  </li>  
    </ul>
  </li>
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul class="collapse">
  <li><a href="#introduction" id="toc-introduction" class="nav-link active" data-scroll-target="#introduction">Introduction</a></li>
  <li><a href="#rationale" id="toc-rationale" class="nav-link" data-scroll-target="#rationale">Rationale</a></li>
  <li><a href="#when-are-data-clean" id="toc-when-are-data-clean" class="nav-link" data-scroll-target="#when-are-data-clean">When are data clean?</a></li>
  <li><a href="#how-do-i-report-the-results-of-data-cleaning" id="toc-how-do-i-report-the-results-of-data-cleaning" class="nav-link" data-scroll-target="#how-do-i-report-the-results-of-data-cleaning">How do I report the results of data cleaning?</a></li>
  <li><a href="#terminology" id="toc-terminology" class="nav-link" data-scroll-target="#terminology">Terminology</a></li>
  <li><a href="#data-cleaning-procedures" id="toc-data-cleaning-procedures" class="nav-link" data-scroll-target="#data-cleaning-procedures">Data cleaning procedures</a>
  <ul class="collapse">
  <li><a href="#reading-your-data-into-r" id="toc-reading-your-data-into-r" class="nav-link" data-scroll-target="#reading-your-data-into-r">Reading your data into R</a></li>
  </ul></li>
  <li><a href="#qa-checklist-for-qual-cleaning" id="toc-qa-checklist-for-qual-cleaning" class="nav-link" data-scroll-target="#qa-checklist-for-qual-cleaning">QA Checklist for Qual Cleaning</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Data Prep</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<p>Manager‚Äôs Summary</p>
<p>Data Cleaner‚Äôs Summary</p>
<section id="introduction" class="level2">
<h2 class="anchored" data-anchor-id="introduction">Introduction</h2>
<p><strong>Do not share this guide outside of Omni</strong></p>
<p>Data cleaning is often one of the first things you will do when you start working with qualitative data at OMNI. Whether we‚Äôre working with interview transcripts, focus group discussions, or open-ended survey responses, the raw data we receive is rarely ready for immediate analysis. Cleaning is not just about tidying up; it‚Äôs about making informed decisions that clarify the meaning and integrity of the data while preparing it for systematic analysis.</p>
<p>The decisions we make during the cleaning process are every bit as complex and impactful as those made during coding and analysis. Thoughtful data cleaning can preserve the richness of qualitative data, while careless decisions can distort or diminish participants‚Äô voices. Therefore, it is especially important to have a strong set of working principles to guide your decisions when cleaning qualitative data.</p>
<p>This guide covers a general approach to qualitative data cleaning, with an emphasis on useful R packages and functions designed to conquer some common challenges. While this guide includes tools and code to make your life easier, it also offers guidelines for making judgment calls about what to remove, retain, or clarify in the data.</p>
<p>The steps in a qualitative data cleaning process will always be informed by two key factors:</p>
<ol type="1">
<li><strong>The state of the data when we (OMNI) receive it</strong></li>
</ol>
<ul>
<li>For example, some transcripts may come from automated services (like Zoom or Otter.ai) and contain timestamps, speaker labels, or filler words that require removal. Others may be professionally transcribed and need minimal cleaning.</li>
</ul>
<ol start="2" type="1">
<li><strong>The specific needs of the project</strong> Because of this variability, we encourage a flexible, judgment-driven approach to data cleaning. The steps described in this guide are common to many projects, but their order and application should be tailored to the needs of the dataset and the analytic goals of the project. Importantly, depending on the type of analysis, different cleaning steps may be required. Consult the analysis plan and research questions in your project materials to verify the needs of the project.</li>
</ol>
<section id="supporting-resources" class="level3">
<h3 class="anchored" data-anchor-id="supporting-resources">Supporting resources</h3>
</section>
</section>
<section id="rationale" class="level2">
<h2 class="anchored" data-anchor-id="rationale">Rationale</h2>
<p>When we clean qualitative data, we apply a series of thoughtful transformations that make the data clearer, more consistent, and usable for analysis. Qualitative data cleaning requires attention to detail and sensitivity to the context in which the data were collected. The procedures we use need to be flexible because the downstream purposes of the data can vary from project to project‚Äîwhether for thematic coding, content analysis, or mixed-methods integration.</p>
<p>The qualitative data cleaner often has to make many judgment calls during this process. These decisions are guided by the project‚Äôs goals, the nature of the source data, team experience, and guidance documents (like this one). Every decision and its rationale should be clearly documented in the data cleaning script or data log (more on that below). Transparency in this process ensures that the cleaned dataset remains trustworthy and aligned with our ethical standards for qualitative research.</p>
<p>Qualitative data cleaning requires a lot of careful thought and attention. The R code that cleans text data needs to be clearly written and well-commented, not only for reproducibility but to ensure that meaning is preserved, and participant voices are not inadvertently altered or diminished. In qualitative work, the cleaning process can directly impact the integrity of the analysis.</p>
<p>Just as with quantitative analysis, qualitative data-cleaning decisions are made with greater ease and clarity when there is a clear work plan, guided by the project‚Äôs research questions or evaluation goals. Having a shared understanding of what the team hopes to explore in the data helps inform:</p>
<p>What should be cleaned What should be preserved (even if messy) What should be flagged for discussion Two especially helpful documents to have before qualitative data cleaning begins are:</p>
<p>A codebook (or at least a data dictionary) This helps ensure consistency in how we treat things like speaker names, special terminology, or sensitive content. A data analysis plan This outlines the team‚Äôs approach to coding and analysis and helps identify if additional cleaning steps are necessary. For example: anonymizing sensitive details or removing artifacts from automated transcription tools (timestamps, filler words, etc.). Whenever possible, we expect teams to develop a data analysis plan and request any available data dictionaries or codebooks from the client or partner organizations who collected the data. However, you may need to create a codebook if one doesn‚Äôt exist‚Äîfeel free to reach out to the QualBPT (or whichever team you want to point folks to) if you need support.</p>
<p>In many cases, the people drafting the analysis plan are different from those cleaning the qualitative data, so strong cross-team communication is essential. We recommend including the qualitative data cleaner (or cleaning team) in project discussions as early as possible. When drafting the analysis plan, think through what text cleaning steps will be necessary to make the data usable for coding, protect participant confidentiality, and meet the project‚Äôs goals.</p>
<p>Finally, whether you‚Äôre writing code for qualitative data cleaning or any other purpose, always write your R scripts as if they will later be:</p>
<ul>
<li>Heavily scrutinized</li>
<li>Held up as example code</li>
<li>Modified by someone brand new to both R and the project</li>
</ul>
<p>Make it easy on future OMNI-ites‚Äîand on your future self!</p>
</section>
<section id="when-are-data-clean" class="level2">
<h2 class="anchored" data-anchor-id="when-are-data-clean">When are data clean?</h2>
<p>‚úÖ What Does It Mean to Have ‚ÄúClean‚Äù Qualitative Data? For there to be project tasks that direct OMNI-ites to ‚Äòclean qualitative data,‚Äô and a guide to help in doing so, there should also be a shared understanding of what it means for qualitative data to be clean.</p>
<p>üìù Definition of Clean Qualitative Data: At OMNI, qualitative data are considered clean when they are organized, de-identified, and ready for analysis or coding.</p>
<p>That means the data:</p>
<p>Accurately reflect the original source material (e.g., interviews, focus groups, or open-text survey responses) Have been transformed into a structure that makes them easy to navigate and analyze Protect the privacy and confidentiality of participants Are consistent, clear, and free of irrelevant clutter (like transcription artifacts) üéØ What Makes a Qualitative Dataset ‚ÄúAnalysis-Ready‚Äù? For qualitative text data to be ready for analysis, they should meet the following criteria:</p>
<p>Speaker Information Is Clear and Consistent</p>
<p>Participant speakers and interviewers are clearly labeled in the data. Each speaker‚Äôs text is grouped logically into segments, preserving conversational flow. Participant Identifiers Are Specified and Protected</p>
<p>Real names, locations, and other direct identifiers have been removed or replaced with participant IDs or pseudonyms. Confidential information (e.g., agency names, job titles, organizations) is anonymized where necessary, following OMNI‚Äôs confidentiality guidelines. Questions Are Clearly Distinguished From Responses</p>
<p>Interviewer questions (or prompts) are labeled or separated from participant responses, as appropriate. This can be done by adding question text as its own field in the dataset or by adding markers in the transcript. Text Segments Are Ordered and Organized</p>
<p>The transcript text is ordered according to the flow of conversation. Segments are correctly time-sequenced (even if timestamps themselves are removed). Text Is Structured Into a Tidy, Rectangular Format</p>
<p>Each row represents a single speaker turn or unit of analysis (e.g., a complete response to a question). Data are stored in a rectangular table (data frame), with columns for: Session name or group (e.g., ‚ÄúEducators‚Äù or ‚ÄúPublic Health‚Äù) Participant ID or role (e.g., ‚ÄúParticipant 1,‚Äù ‚ÄúFacilitator‚Äù) Text segment (the response or comment) Any relevant metadata (e.g., discussion section, date) Timestamps and Transcription Artifacts Are Removed</p>
<p>All timestamps (e.g., [00:05:23], (0:12:45)) are deleted unless specifically required for analysis. Automated transcription quirks (e.g., repeated words, filler words, auto-captions like ‚Äú[inaudible]‚Äù) are reviewed, cleaned, or flagged. Text Is Consistent in Style and Format</p>
<p>All text is converted to lowercase, unless case is important for analysis. Spelling errors are corrected when they obscure meaning (but regional spellings or participant quirks may be preserved if relevant). Punctuation and spacing are standardized (no excessive whitespace, missing periods, etc.). Relevant Identifiers Are Added to the Dataset</p>
<p>If there are multiple sessions or groups, these are labeled (e.g., ‚ÄúEducators,‚Äù ‚ÄúPublic Health‚Äù). If there are themes or discussion sections (e.g., ‚ÄúChallenges,‚Äù ‚ÄúRecommendations‚Äù), these are identified. If codes are pre-assigned for analytic purposes (e.g., ‚ÄúPre-implementation,‚Äù ‚ÄúPost-implementation‚Äù), they are included in the data structure. üí° How Do We Know When Qualitative Data Are Clean? Here are some guiding questions to help determine when qualitative data are ready for analysis (i.e., clean):</p>
<p>What is the plan for coding or analyzing this data?</p>
<p>The analysis plan (or coding framework) should inform cleaning decisions. For example, if the team plans to do thematic coding, they‚Äôll need text organized into meaningful speaker turns or responses. What needs to be anonymized?</p>
<p>Identify any sensitive information that must be redacted or replaced to maintain confidentiality and ensure participant privacy. Are speaker turns properly attributed and easy to follow?</p>
<p>Each speaker‚Äôs contributions should be clearly labeled, consistently formatted, and grouped logically. Are responses to specific questions clearly identifiable?</p>
<p>If interviews or focus groups follow a semi-structured guide, it‚Äôs important to separate questions from responses for clarity in analysis. Is the structure of the data appropriate for the analytic tool?</p>
<p>If the data are being uploaded to Dedoose, NVivo, or another platform, they should follow the required format (e.g., tidy data frame with speaker IDs and group names). Have all unnecessary artifacts been removed?</p>
<p>Time stamps, filler words, and transcription errors that don‚Äôt add value to the analysis should be removed. Has the cleaned data been reviewed by someone else (QA check)?</p>
<p>Whenever possible, have another OMNI-ite review the cleaned data for accuracy and completeness. ‚ú® Common Issues to Discuss Early in the Cleaning Process Just like in quantitative data cleaning, clarifying expectations at the start of a project will save time later. For qualitative projects, consider these:</p>
<p>Will we analyze both facilitator questions and participant responses, or just participant responses? How will we handle overlapping speech, interruptions, or incomplete thoughts? Do we need to standardize participant roles (e.g., ‚ÄúPublic Health Official‚Äù vs.&nbsp;‚ÄúPH Staff‚Äù) for consistency? Are we preparing data for manual coding or automated text analysis? Do we need to translate or transcribe non-English responses? Do we need to connect text segments with broader context, such as the discussion theme or section of the focus group? üöÄ In the Following Sections‚Ä¶ We‚Äôll see how these fundamentals‚Äîlike tidy qualitative data, pipes, and regular expressions‚Äîplay out in real-world cleaning tasks, such as:</p>
<p>Removing timestamps and filler words Labeling speakers and organizing segments Anonymizing sensitive information Structuring text for analysis software (Dedoose, NVivo, etc.) ‚úÖ Quick Summary of ‚ÄúClean Qualitative Data‚Äù at OMNI: Clean qualitative data are:</p>
<p>Anonymized Clearly structured and labeled Organized for easy analysis Free of unnecessary artifacts Ready for use in coding and interpretation</p>
</section>
<section id="how-do-i-report-the-results-of-data-cleaning" class="level2">
<h2 class="anchored" data-anchor-id="how-do-i-report-the-results-of-data-cleaning">How do I report the results of data cleaning?</h2>
<p>üìù How to Report the Results of Qualitative Data Cleaning at OMNI Cleaning qualitative data is an interpretive and decision-heavy process, and those decisions need to be transparent. Reporting your cleaning process helps:</p>
<p>Project leads understand what‚Äôs been done and why. Provide documentation in case changes need to be made later. Build trust in the integrity of the cleaned dataset. Support future qualitative coding, interpretation, and reporting. Qualitative data cleaning produces results‚Äîchanges to the text or data structure‚Äîthat should be documented in a clear, shareable data cleaning report.</p>
<p>üìã What to Include in a Qualitative Data Cleaning Report 1. Summary of the Dataset You Cleaned Start with an overview:</p>
<p>How many transcripts or files were cleaned? How many sessions (e.g., focus groups, interviews) are included? What types of participants are represented (e.g., educators, public health professionals)? Example: This dataset includes transcripts from 8 focus groups, with 42 participants. Participants represent two stakeholder groups: Educators (n = 20) and Public Health Professionals (n = 22).</p>
<ol start="2" type="1">
<li>Anonymization and De-Identification Steps Document what you removed or replaced to protect confidentiality.</li>
</ol>
<p>Were participant names replaced with IDs (e.g., Participant 01)? Were organizations, locations, or personal identifiers removed or redacted? Were job titles generalized (e.g., ‚ÄúCEO‚Äù changed to ‚Äúsenior leader‚Äù)? Example: Replaced all participant names with Participant IDs (e.g., P01). Removed specific references to organizations and locations (e.g., ‚Äúat Boulder Community Hospital‚Äù becomes ‚Äúat [hospital]‚Äù). Redacted job titles for anonymity when mentioned alongside unique organizations.</p>
<ol start="3" type="1">
<li>Speaker Labeling and Text Structuring Describe how speakers were labeled and how the transcript was organized.</li>
</ol>
<p>Were speakers consistently labeled as ‚ÄúParticipant‚Äù and ‚ÄúFacilitator‚Äù? Was each speaker turn separated into its own row or segment? Were questions separated from responses? Example: Speaker turns were labeled consistently as either Facilitator or Participant. Each speaker turn is stored as one row in the cleaned dataset, with associated metadata (Session name, Speaker role, Discussion section).</p>
<ol start="4" type="1">
<li>Artifacts Removed (Timestamps, Filler Words, etc.) Note what transcription artifacts were removed or edited:</li>
</ol>
<p>Were timestamps deleted? Were filler words (e.g., ‚Äúum,‚Äù ‚Äúuh‚Äù) removed? If so, specify whether this was systematic or case-by-case. Were transcription errors corrected? Example: Removed all timestamps in the format [hh:mm:ss]. Deleted common filler words (‚Äúum,‚Äù ‚Äúuh‚Äù) unless they contributed to participant meaning or tone. Reviewed and corrected auto-transcription errors (e.g., ‚ÄúDodoose‚Äù corrected to ‚ÄúDedoose‚Äù).</p>
<ol start="5" type="1">
<li>Text Standardization and Formatting Summarize standardization steps for readability and consistency:</li>
</ol>
<p>Was text converted to lowercase? Was spelling corrected? If so, did you preserve participant colloquialisms? Were consistent punctuation and spacing applied? Example: Converted all text to lowercase for consistency. Standardized punctuation (e.g., added periods to sentence ends where missing). Corrected spelling errors that obscured meaning but preserved participant vernacular and tone where appropriate.</p>
<ol start="6" type="1">
<li>Metadata or Contextual Information Added Note any metadata added to support analysis:</li>
</ol>
<p>Session name (e.g., ‚ÄúEducators‚Äù vs.&nbsp;‚ÄúPublic Health Professionals‚Äù) Discussion section (e.g., ‚ÄúChallenges,‚Äù ‚ÄúRecommendations‚Äù) Participant role or group designation Example: Added metadata fields to identify Session Name, Participant Group (Educator/Public Health), and Discussion Section (Barriers, Facilitators, Recommendations).</p>
<ol start="7" type="1">
<li>Key Decisions Made During Cleaning Flag any important decisions that could impact analysis:</li>
</ol>
<p>If you excluded any portions of text (e.g., off-topic discussions), document what was excluded and why. If you made choices about retaining or removing interruptions, overlapping speech, or non-verbal cues, describe the rationale. If you generalized identifying details in ways that may impact interpretation, note this. Example: Excluded introductory small talk (greetings, logistics discussions) from the analysis dataset. Retained overlapping speech where relevant to the discussion. Generalized certain job titles to preserve anonymity (e.g., ‚ÄúHead Nurse‚Äù changed to ‚ÄúMedical Staff‚Äù).</p>
<ol start="8" type="1">
<li>Counts and Summaries Where Relevant When helpful, include counts that summarize:</li>
</ol>
<p>How many identifiers were removed? How many sessions, speakers, or responses are in the final dataset? If you organized by themes, how many segments are in each theme? Example: Final cleaned dataset includes 8 focus groups, 42 participants, and 620 participant responses across three discussion sections: Challenges (n = 220), Facilitators (n = 200), and Recommendations (n = 200).</p>
<p>üí° Tips for Reporting Qualitative Data Cleaning Be Transparent Even small decisions (e.g., standardizing speaker labels) can have big implications during analysis. If you‚Äôre unsure whether to document something, document it!</p>
<p>Take the Perspective of Your Project Lead or Analyst What decisions might they need to revisit later? What context would help them understand how the data were shaped?</p>
<p>Support Replicability and Quality Control Your cleaning report should make it easy for another team member to:</p>
<p>Understand what was done Re-run the cleaning script Suggest or request changes with full knowledge of the process üñºÔ∏è Example Summary Table in a Qualitative Cleaning Report Cleaning Step Action Taken Notes Anonymization Removed names, replaced with Participant IDs (P01-P42) Locations and job titles generalized Speaker Labeling Labeled as Facilitator or Participant Consistent across all sessions Timestamps Removed Deleted all timestamps (hh:mm:ss)<br>
Filler Words Removed ‚Äúum,‚Äù ‚Äúuh‚Äù except when indicating hesitation Case-by-case review Text Standardization Converted to lowercase, corrected major spelling errors Preserved participant language/tone Metadata Added Session name, participant group, discussion section Useful for subgroup analysis Exclusions Removed introductions, off-topic discussions Documented in the data log</p>
</section>
<section id="terminology" class="level2">
<h2 class="anchored" data-anchor-id="terminology">Terminology</h2>
<p>üìù Relevant Terminology for Qualitative Data Cleaning in R üîß Data Structure &amp; Format Terms Transcript A written or typed record of spoken language from interviews, focus groups, or meetings. Transcripts may include speaker labels, timestamps, and other artifacts that need cleaning.</p>
<p>Turn-Taking Each time a participant or facilitator speaks is called a ‚Äúturn.‚Äù Clean data often organize these turns into individual rows in a dataset.</p>
<p>Segment (or Excerpt) A portion of text, such as a paragraph, sentence, or speaker turn, treated as a unit for coding or analysis. Segments are often defined by the speaker‚Äôs response or by topic.</p>
<p>Tidy Data Data where:</p>
<p>Each row represents a single observation (e.g., a speaker turn or segment) Each column contains one type of information (e.g., speaker ID, text, session group) Tidy data make it easier to manipulate, clean, and analyze qualitative datasets in R. Rectangular Data Another term for a table or data frame, where rows and columns are used to organize data in R.</p>
<p>üóÇÔ∏è Qualitative Metadata &amp; Labeling Terms Speaker Label An identifier showing who is speaking (e.g., ‚ÄúFacilitator,‚Äù ‚ÄúParticipant 1‚Äù). Clean data should use consistent speaker labels.</p>
<p>Participant ID A unique identifier assigned to participants to protect anonymity (e.g., ‚ÄúP01‚Äù). These are often used in place of names.</p>
<p>Session ID / Group The label identifying the specific interview or focus group a participant was part of (e.g., ‚ÄúSession 1 ‚Äì Educators‚Äù).</p>
<p>Discussion Section / Topic Area A label identifying a portion of the conversation (e.g., ‚ÄúBarriers,‚Äù ‚ÄúRecommendations‚Äù) to help organize qualitative data.</p>
<p>‚úÇÔ∏è Data Cleaning &amp; Transformation Terms Anonymization / De-Identification The process of removing or replacing personal identifiers (e.g., names, locations, job titles) to protect participant privacy.</p>
<p>Standardization Making text consistent in format (e.g., converting to lowercase, consistent punctuation, spacing).</p>
<p>Tokenization (Optional depending on your analysis!) Breaking down text into smaller parts‚Äîwords, sentences, or phrases‚Äîtypically for text mining. Not always part of standard qualitative coding workflows.</p>
<p>Filtering Removing unnecessary rows or segments (e.g., small talk, off-topic responses) from the data.</p>
<p>Recoding Transforming data from one format to another (e.g., generalizing job titles or grouping participant roles).</p>
<p>Join / Merge Combining two datasets based on a shared key (e.g., merging participant demographic info with transcripts).</p>
<p>Pivoting Restructuring data from wide format (many columns) to long format (many rows), or vice versa, to make it easier to analyze or display.</p>
<p>üè∑Ô∏è Text Cleaning Terms Timestamps Time markers in transcripts (e.g., [00:12:34]) that need to be removed unless necessary for the analysis.</p>
<p>Filler Words Common speech disfluencies (e.g., ‚Äúum,‚Äù ‚Äúuh,‚Äù ‚Äúlike‚Äù) that can be removed for clarity, depending on analysis goals.</p>
<p>Inaudibles / Transcription Errors Markers like ‚Äú[inaudible]‚Äù or machine transcription errors that need to be corrected or flagged.</p>
<p>Spelling and Grammar Standardization Correcting spelling errors that make text difficult to read, while preserving participant voice and tone where relevant.</p>
</section>
<section id="data-cleaning-procedures" class="level1">
<h1>Data cleaning procedures</h1>
<p>The first step we‚Äôll need to take is to figure out what kind of document you want to read into R.</p>
<section id="reading-your-data-into-r" class="level2">
<h2 class="anchored" data-anchor-id="reading-your-data-into-r">Reading your data into R</h2>
<p>First, we‚Äôll need to read our data into R. Depending on how your raw text is stored, you‚Äôll need to take various steps to read in your data for analysis. The goal is to turn any of your text into a dataframe with rows and columns of your text responses. In some cases, you may need to keep participant ID columns or other columns if you‚Äôre doing a mixed-method analysis. In other cases, you may be analyzing different focus groups and comparing them to eachother. Whatever you are doing, make sure your dataframe is set up or your analysis. If you are unsure about this, ask Hannah or a member of Qual BPT for some help!</p>
<p>Here is an example of what your data may look like when you first read it into R.</p>
<p><img src="dirty_data.png" class="img-fluid"></p>
<p>and here‚Äôs what we want it to look like (eventually) for most of our analysis needs.</p>
<p><img src="clean_data.png" class="img-fluid"></p>
<p>With clean data, we can:</p>
<ul>
<li><p>Compare participants‚Äô responses across sessions and discussion sections. We could answer questions like:</p>
<ul>
<li><p>What did Educators say about Community Impact vs.&nbsp;Public Health?‚Äù</p></li>
<li><p>What did participants across all interviews think about abatement funds?</p></li>
</ul></li>
<li><p>Filter by participant role (e.g., facilitators vs.&nbsp;participants) for targeted analysis. We could answer questions like:</p>
<ul>
<li><p>How many participants mentioned that the county should invest in wraparound services across all interviews?</p></li>
<li><p>What is the most common barrier in accessing services in the county?</p></li>
</ul></li>
<li><p>Preserve anonymity by removing names and identifiers.</p></li>
</ul>
<section id="zoom-transcripts" class="level3">
<h3 class="anchored" data-anchor-id="zoom-transcripts">Zoom transcripts</h3>
<p>One of the main forms of qualitative data we receive includes Zoom transcripts. Below is a function you can use to clean your Zoom transcripts and get them to a tidy format by entering the interviewer name(s), and key phrases used by the interviewer to mark the section of the discussion. For example, an interview might begin with an introduction, then include a discussion of barriers, and a discussion of strengths. We‚Äôll likely want to separate these out into sections so our analyses can speak to each section independent of each other, rather than be clumped altogether.</p>
<p>And when you want to clean the transcripts and mark the interviewer, you can add the names of the interviewers here.</p>
<p>This function works for Zoom transcripts that are saved as Word documents or .txt files. There are few things you need to specify in the function, including updating the file path, the interviewers, setting your list of questions, adding section labels, and the session name.</p>
<p>This example comes from the Loudoun County Opioid Abatement project where Shon, Lindsay, Hannah, Luke, Eden, and Arden are staffed, so any of them could have been an interviewer.</p>
<p><span class="citation" data-cites="QUALBPT">@QUALBPT</span> is there anything listed here that may be helpful to add that we might want to analyze or examine? <span class="citation" data-cites="QUALBPT">@QUALBPT</span> is there ever a case where we would need to analyze the interviewer‚Äôs language?</p>
<p>In the case where an interviewer asks a question an exact way, we can enter the question as it is listed on the interview guide. However, this is not always the best way to run an interview when you‚Äôre following a more relaxed vibe. So, it may be helpful to have the interview guide (or deck, whatever the interviewer used to facilitate the discussion) and the transcript opened to identify the order of discussion and section labels, and to identify where those key markers of the text are going to identify your questions.</p>
<p>What is a good example of a question list if the interviewer did not read the question verbatim? Let‚Äôs imagine the first question listed on the interview guide is ‚ÄúWhat kinds of barriers do you think prevent community members from accessing services in the county?‚Äù.</p>
<p>Bad example: ‚Äúaccessing services‚Äù this is a bad example because this phrase has been marked as an identifier for a question, so any instance of ‚Äúaccessing services‚Äù comes up will count the phrase as a question.</p>
<p>Good example: ‚Äúbarriers do you think prevent community members from accessing services‚Äù it is less likely for someone to have used this exact string of words in the conversation, so we‚Äôre safe to mark this as a question identifier.</p>
</section>
<section id="pdfs" class="level3">
<h3 class="anchored" data-anchor-id="pdfs">PDFs</h3>
</section>
<section id="excel-sheets" class="level3">
<h3 class="anchored" data-anchor-id="excel-sheets">Excel sheets</h3>
<p>Of course, we also tend to ask qualitative questions in some of our surveys at OMNI, and these types of data should be read in like quantitative data and should already be in a clean format if you follow the data cleaning guide (insert link to data cleaning guide).</p>
</section>
<section id="qualbpt-any-other-forms-of-text-we-use" class="level3">
<h3 class="anchored" data-anchor-id="qualbpt-any-other-forms-of-text-we-use"><span class="citation" data-cites="QUALBPT">@QUALBPT</span> Any other forms of text we use?</h3>
</section>
</section>
</section>
<section id="qa-checklist-for-qual-cleaning" class="level1">
<h1>QA Checklist for Qual Cleaning</h1>
<p>[ ] Are participant and interviewer roles correctly labeled? [ ] Have names, locations, and job titles been de-identified? [ ] Are timestamps removed (unless needed for analysis)? [ ] Are discussion sections correctly labeled? [ ] Has text been standardized (case, punctuation, spacing)? [ ] Is the cleaned dataset in a tidy format (one speaker turn per row)? [ ] Has the cleaned dataset been reviewed by another team member?</p>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "Óßã";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
      &nbsp;
    </div>   
    <div class="nav-footer-center">
<p>Copyright 2025, Omni Institute</p>
</div>
    <div class="nav-footer-right">
<p><a href="https://www.omni.org/"><img src="https://github.com/rfortherestofus/omni/blob/main/inst/assets/images/logo.png?raw=true" class="img-fluid" alt="Omni institute" width="100"></a></p>
</div>
  </div>
</footer>




</body></html>